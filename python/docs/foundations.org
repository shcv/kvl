#+TITLE: KVL and CCL: Mathematical Foundation and Relationship

* Introduction

Key-Value Language (KVL) is a Python implementation inspired by the Categorical Configuration Language (CCL) created by Dmitrii Kovanikov (chshersh), as described in his blog post [[https://chshersh.com/blog/2025-01-06-the-most-elegant-configuration-language.html]["The Most Elegant Configuration Language"]].

Both languages share a mathematical foundation based on Category Theory, but KVL extends CCL with practical features for Python development while preserving the core mathematical properties.

* Mathematical Foundation

Both CCL and KVL are built on semigroup and monoid abstractions from Category Theory.

** Core Properties

*** Associativity
The fundamental property is that configuration merging is associative:

#+BEGIN_EXAMPLE
(A ⊕ B) ⊕ C = A ⊕ (B ⊕ C)
#+END_EXAMPLE

This means the order of merging operations doesn't matter, ensuring predictable and composable configurations.

*** Identity
An empty configuration serves as the identity element:

#+BEGIN_EXAMPLE
empty ⊕ A = A ⊕ empty = A
#+END_EXAMPLE

Together, these properties make configurations form a *monoid*, enabling mathematical reasoning about configuration composition.

** Fixed-Point Representation

Both languages use a recursive fixed-point representation for nested structures. In CCL's OCaml:

#+BEGIN_SRC ocaml
type t = Fix of t Map.Make(String).t
#+END_SRC

This creates a map from strings to itself, with empty maps as terminal values.

* CCL: The Original Design

CCL embodies mathematical elegance through extreme minimalism:

- Everything is a key-value pair
- Values are strings (no type inference)
- Nested structures through indentation
- Fixed-point parsing creates recursive structures
- Mathematical purity over convenience

#+BEGIN_SRC ccl
# Simple CCL configuration
name = Dmitrii
server =
  host = localhost
  port = 8080
#+END_SRC

* KVL: Practical Extensions

KVL preserves CCL's mathematical foundation while adding practical features for Python development:

** 1. Configurable Separators

While CCL uses only `=`, KVL supports multiple separators with context-appropriate spacing:

#+BEGIN_SRC kvl
# Different separator styles
host = localhost      # Classic CCL style
host: localhost      # YAML-like (no space before colon)
host -> localhost    # Arrow style (spaces around arrow)
#+END_SRC

** 2. Optional Type Inference

KVL can optionally infer types while preserving string-by-default behavior:

#+BEGIN_SRC python
# CCL-style (everything as strings)
data = kvl.loads("port = 8080")
print(data["port"])  # "8080" (string)

# With schema (type conversion)
schema = Schema({"port": int})
data = schema.loads("port = 8080")
print(data["port"])  # 8080 (integer)
#+END_SRC

** 3. Transform Utilities

KVL provides optional transformations for Python convenience:

#+BEGIN_SRC python
# Raw CCL-style parsing
raw = kvl.loads("""
tags = web
tags = api
""")
# Result: {"tags": {"web": {}, "api": {}}}

# With compacting
compacted = kvl.compact(raw)
# Result: {"tags": ["web", "api"]}

# Reversible transformation
expanded = kvl.expand(compacted)
# Back to: {"tags": {"web": {}, "api": {}}}
#+END_SRC

** 4. Schema System

KVL adds optional schema support for validation and type conversion:

#+BEGIN_SRC python
schema = Schema({
    "port": (int, lambda v: 1 <= v <= 65535),
    "debug": bool,
    "tags": list  # Auto-compacts repeated keys
})

config = schema.loads("""
port = 8080
debug = true
tags = web
tags = api
""")
# Result: {"port": 8080, "debug": True, "tags": ["web", "api"]}
#+END_SRC

* Key Differences Summary

| Aspect     | CCL                 | KVL                                    |
|------------+---------------------+----------------------------------------|
| Philosophy | Mathematical purity | Practical with mathematical foundation |
| Types      | Strings only        | Configurable type inference            |
| Separators | `=` only            | `=`, `:`, `->`, etc.                   |
| Transforms | None                | Optional compacting/expansion          |
| Schema     | External            | Integrated validation                  |
| Target     | Language-agnostic   | Python-optimized                       |

* Mathematical Preservation

Despite the practical extensions, KVL preserves CCL's mathematical properties:

#+BEGIN_SRC python
# Associativity preserved
a = kvl.loads("x = 1")
b = kvl.loads("y = 2")
c = kvl.loads("z = 3")

# These are equivalent
result1 = kvl.merge(kvl.merge(a, b), c)
result2 = kvl.merge(a, kvl.merge(b, c))
assert result1 == result2

# Monoid homomorphism preserved
# parse(concat(file1, file2)) = merge(parse(file1), parse(file2))
#+END_SRC

* When to Use Each

** Use CCL when:
- Mathematical purity is paramount
- Minimal implementation desired
- No need for type conversion

** Use KVL when:
- Type safety and validation needed
- Convenience features desired

* Conclusion

KVL extends CCL's elegant mathematical foundation with a few practical features.
The relationship is one of respectful extension: CCL provides the theoretical foundation and mathematical rigor, while KVL adds pragmatic features without sacrificing the core properties that make configuration composition reliable and predictable.

* References
** Original Sources
- [[https://chshersh.com/blog/2025-01-06-the-most-elegant-configuration-language.html][The Most Elegant Configuration Language]] - Dmitrii Kovanikov's original CCL blog post
- [[https://github.com/chshersh/ccl][CCL GitHub Repository]] - Original OCaml implementation
** Mathematical Concepts
- [[https://en.wikipedia.org/wiki/Semigroup][Semigroup (Wikipedia)]] - Introduction to semigroups and associativity
- [[https://en.wikipedia.org/wiki/Monoid][Monoid (Wikipedia)]] - Monoids as semigroups with identity
- [[https://bartoszmilewski.com/2014/11/04/category-the-essence-of-composition/][Category: The Essence of Composition]] - Bartosz Milewski on Category Theory basics
- [[https://www.math3ma.com/blog/what-is-a-monoid][What is a Monoid?]] - Gentle introduction by Tai-Danae Bradley
** Dmitrii Kovanikov's Pragmatic Category Theory Series
- [[https://chshersh.com/posts/2022-08-18-pragmatic-category-theory-part-01.html][Part 1: Semigroup]] - Deep dive into semigroups
- [[https://chshersh.com/posts/2022-11-05-pragmatic-category-theory-part-02.html][Part 2: Monoid]] - Monoids and their applications
- [[https://chshersh.com/posts/2023-10-13-pragmatic-category-theory-part-03.html][Part 3: Associativity]] - Why associativity matters
** Fixed Points and Recursion
- [[https://en.wikipedia.org/wiki/Fixed_point_(mathematics)][Fixed Point (Wikipedia)]] - Mathematical concept of fixed points
[[https://www.cs.cmu.edu/~rwh/introsml/core/fixpoints.htm][- Fixed Points in Programming]] - Robert Harper on fixed points in ML
** Monoid Homomorphisms
- [[https://en.wikipedia.org/wiki/Monoid#Monoid_homomorphisms][Monoid Homomorphisms (Wikipedia)]] - Structure-preserving maps
- [[https://ncatlab.org/nlab/show/monoid+homomorphism][nLab: Monoid Homomorphism]] - Category theory perspective
