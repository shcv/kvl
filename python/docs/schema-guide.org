#+TITLE: KVL Schema System Guide
#+SUBTITLE: Flexible Recursive Field Validation

* Overview

The KVL Schema system provides flexible, recursive validation of KVL data structures using a field-oriented approach. Unlike traditional object-oriented schemas that require predefined object shapes, KVL schemas allow field specifications to match anywhere in the data hierarchy.

** Core Principles

1. *Field-Oriented Validation* - Field specifications apply based on field names, not object structure
2. *Recursive Matching* - Schema validation traverses data recursively, checking each key against all root schema keys  
3. *Root-Based Resolution* - All data keys are checked against the complete set of root schema keys, regardless of nesting level
4. *Flexible Inheritance* - Any field can match any root specification, providing maximum flexibility

** Key Benefits

- *Handles dynamic keys* - Perfect for categorical data like states, countries, or user-generated content
- *Reduces duplication* - Define field types once, apply everywhere
- *Natural scoping* - More specific subschema definitions override general ones
- *Composable* - Mix and match field definitions for complex validation needs

* Schema Definition Syntax

** Simple Field Specifications

Basic type definitions apply globally to any field with that name:

#+begin_src kvl
# Basic type definitions
population = int
capital = string
active = bool
score = float
#+end_src

** Complex Field Specifications

Add constraints and validation rules:

#+begin_src kvl
port = 
    type = int
    min = 1
    max = 65535

name = 
    type = string
    max-length = 50
    pattern = ^[A-Za-z\s]+$

tags = 
    type = list
    min-items = 1
    max-items = 10
#+end_src

** Nested Field Specifications

Create scoped validation contexts for more specific matching:

#+begin_src kvl
# Global default for any 'port' field
port = int

# More specific validation when port appears under 'server'
server = 
    host = string
    port = 
        type = int
        min = 8000
        max = 9000

# Different validation when port appears under 'database'  
database = 
    host = string
    port = 
        type = int
        min = 3306
        max = 5432
#+end_src

* Schema Configuration

** Coverage Control (open/closed)

Controls whether unknown fields are allowed:

- *closed* - All leaf values must match some schema specification (strict validation)
- *open* (default) - Leaf values may exist without schema specifications (pass-through)

** Field Requirement Control (required/optional)

Controls whether fields in matched subschemas must be present:

- *required = false* (default) - Fields in matched subschemas are optional
- *required = true* - Fields in matched subschemas must be present

** Schema Headers

Configure schema behavior using headers:

#+begin_src kvl
#= kvl 1.0 schema open optional
#= kvl 1.0 schema closed required  
#= kvl 1.0 schema open required
#+end_src

** Per-Field Required Overrides

Override the schema default for specific fields:

#+begin_src kvl
#= kvl 1.0 schema open optional

server = 
    host = 
        type = string
        required = true     # This field must be present

    port = 
        type = int
        required = false    # This field is optional
#+end_src

* Validation Algorithm

** Step 1: Root Key Matching

For each key in the data:
1. Check if key matches ANY root schema key
2. If match found: apply that schema specification recursively
3. If no match found: proceed based on coverage setting (open/closed)

** Step 2: Recursive Validation

When a root key matches:
1. If schema value is a simple type: validate data value against type
2. If schema value is a constraint spec: validate data value against constraints  
3. If schema value is a nested object: recursively validate data value contents

** Step 3: Subschema Validation

Within a matched subschema context:
1. Data keys first checked against subschema specifications
2. If no subschema match: checked against ALL root schema keys
3. Most specific match (subschema) takes precedence over general (root)

** Step 4: Required Field Checking

After validating a matched subschema:
1. Check if all required fields are present
2. Use per-field =required= settings if specified
3. Fall back to schema default =required= setting

* Examples

** Example 1: States Data (Open Schema)

Perfect for categorical data with unknown parent keys:

*Schema:*
#+begin_src kvl
#= kvl 1.0 schema open optional

population = int
capital = string
median_income = int
white = float
black = float
hispanic = float
#+end_src

*Data:*
#+begin_src kvl
Alabama = 
    capital = Montgomery      # Matches root 'capital = string'
    population = 5224279      # Matches root 'population = int'
    founded = 1819           # No match, open schema → pass through

Texas = 
    capital = Austin         # Matches root 'capital = string'  
    nickname = "Lone Star"   # No match, open schema → pass through
    population = 30976754    # Matches root 'population = int'
#+end_src

*Result:* Valid. All matched fields validated, unmatched fields passed through.

** Example 2: Server Configuration (Closed Schema)

Strict validation for known configuration structures:

*Schema:*
#+begin_src kvl  
#= kvl 1.0 schema closed optional

timeout = int
server = 
    host = string
    port = int

database = 
    host = string
    port = 
        type = int
        min = 3306
        max = 5432
#+end_src

*Data:*
#+begin_src kvl
server = 
    host = localhost         # Matches server.host
    port = 8080             # Matches server.port  
    timeout = 30            # No match in server subschema → matches root 'timeout'
#+end_src

*Result:* Valid. All fields match schema specifications.

** Example 3: Required Field Validation

Control which fields must be present:

*Schema:*
#+begin_src kvl
#= kvl 1.0 schema open required

server = 
    host = 
        type = string
        required = true      # Must be present

    port = 
        type = int
        required = false     # Optional (overrides schema default)
#+end_src

*Valid Data:*
#+begin_src kvl
server = 
    host = localhost        # Required field present ✓
    # port omitted but optional ✓
#+end_src

*Invalid Data:*
#+begin_src kvl
server = 
    port = 8080            # host missing but required ✗
#+end_src

** Example 4: Mixed Scoping

Demonstrate global defaults with specific overrides:

*Schema:*
#+begin_src kvl
#= kvl 1.0 schema open optional

# Global field specifications
port = int
host = string
timeout = int

# Context-specific overrides
server = 
    port = 
        type = int
        min = 8000          # More restrictive than global
        max = 9000

    ssl = bool

database = 
    port = 
        type = int
        enum = 3306,5432    # Specific allowed values
#+end_src

*Data:*
#+begin_src kvl
server = 
    host = localhost        # Matches server.host → falls back to root 'host = string'
    port = 8080            # Matches server.port → uses server-specific constraints
    ssl = true             # Matches server.ssl
    timeout = 30           # No match in server → matches root 'timeout = int'

database = 
    host = db.local        # Matches database.host → falls back to root 'host = string'  
    port = 3306            # Matches database.port → uses database-specific constraints
#+end_src

* Type System

** Supported Types

- =string= / =str= - Text values
- =integer= / =int= - Whole numbers  
- =float= / =number= - Decimal numbers
- =boolean= / =bool= - True/false values
- =list= / =array= - Collections of items
- =object= / =dict= - Nested key-value structures
- =datetime= / =date= - Date and time values

** Type Conversion

Values are automatically converted to the specified type when possible:

- Strings to numbers: ="123"= → =123=
- Strings to booleans: ="true"=, ="yes"=, ="1"= → =true=
- KVL categorical structure to lists: ={red = {}, green = {}, blue = {}}= → =["red", "green", "blue"]=

** Constraint Types

*** Numeric Constraints
- =min= - Minimum value
- =max= - Maximum value

*** String Constraints  
- =min-length= - Minimum string length
- =max-length= - Maximum string length
- =pattern= - Regular expression pattern

*** List Constraints
- =min-items= - Minimum number of items
- =max-items= - Maximum number of items

*** Enumeration Constraints
- =enum= - Comma-separated list of allowed values

* API Reference

** Schema Class

*** Constructor
#+begin_src python
Schema(fields, open=True, required=False)
#+end_src

- =fields= - Dictionary of field specifications
- =open= - Allow unmatched fields (default: True)
- =required= - Fields in matched subschemas must be present (default: False)

*** Methods

**** =validate(data, path="")=
Validate data against schema without conversion.

**** =deserialize(data, path="")=
Validate and convert data to typed Python objects.

**** =serialize(data, path="")=
Convert typed Python objects back to KVL-compatible format.

**** =loads(kvl_text)=
Parse KVL text and validate against schema.

**** =load(file_or_path)=
Load KVL file and validate against schema.

**** =dumps(data, **options)=
Serialize data and convert to KVL text.

**** =dump(data, file_or_path, **options)=
Serialize data and write to KVL file.

*** Class Methods

**** =Schema.from_kvl(kvl_text)=
Create schema from KVL schema definition text.

**** =Schema.from_file(file_path)=
Load schema from .schema.kvl file.

* Error Handling

** Validation Errors

- =KvlValidationError= - Data doesn't match schema structure
- =KvlTypeError= - Type conversion failed
- =KvlSchemaError= - Schema definition is invalid

** Error Context

All errors include:
- *Field path* - Location of the error in the data structure
- *Expected type/constraint* - What was expected
- *Actual value* - What was found
- *Helpful message* - Human-readable description

* Best Practices

** Schema Design

1. *Start with global field specs* - Define common fields at the root level
2. *Add specific overrides* - Use nested specs only when needed
3. *Use open schemas* - For flexible, evolving data structures
4. *Use closed schemas* - For strict, well-defined configurations
5. *Minimize required fields* - Only require truly essential fields

** Performance Considerations

1. *Simple specs are faster* - Use basic types when possible
2. *Avoid deep nesting* - Keep schema structure relatively flat
3. *Cache schema objects* - Reuse schema instances for multiple validations
4. *Use appropriate coverage* - Closed schemas are faster but less flexible

** Debugging

1. *Enable path tracking* - Error messages show exact field locations
2. *Test with small data* - Validate schema design with simple examples
3. *Use schema headers* - Clearly document schema intentions
4. *Validate schema files* - Ensure schema definitions are correct

* Python API Examples

** Basic Usage

#+begin_src python
from kvl import Schema

# Create schema with global field specs
schema = Schema({
    'population': int,
    'capital': str,
    'active': bool
})

# Validate states data
data = schema.loads("""
Alabama = 
    capital = Montgomery
    population = 5224279
    active = true

Alaska = 
    capital = Juneau  
    population = 740339
    active = true
""")

print(data['Alabama']['population'])  # 5224279 (int)
#+end_src

** Complex Constraints

#+begin_src python
# Schema with constraints and nested specs
schema = Schema({
    'population': {
        'type': int,
        'min': 0
    },
    'server': {
        'port': {
            'type': int,
            'min': 8000,
            'max': 9000
        }
    }
})
#+end_src

** Schema Files

#+begin_src python
# Load schema from file
schema = Schema.from_file('states.schema.kvl')

# Use with data files
states = schema.load('states.kvl')
#+end_src